Section 1
---------

What features does the app need?

    Invite promoters
    Creating accounts
    Logging in as a promoter
    Adding concerts
    Editing concerts
    Publishing concerts
    Integration with stripe connect to do direct payouts
    Purchasing tickets

        We don't necessarily want to do these in the order given, we want to go through this list and work through
        what these steps entail and if we even need to do them

            Purchasing tickets, we need this.

            We can do direct payouts with stripe manually. Stripe will accept all the payments from customers, we
            will have all of our payments in an account and every so often we will manually payout to concert
            promoters their cut.

            Publishing concert's doesn't have to be done by the promoter, a promoter can reach out to us and we
            can simply toggle the publishing of a concert for now.

            Editing concerts, the promoter doesn't need access to this right away. They can send an email to us
            with the details and we can enter it manually.

            Adding concerts, same as the above.

            Creating accounts isn't needed since now we have no immediate need after eliminating the above.

            Inviting promoters, same as the above.

        So we come to the conclusion that purchasing the tickets is the most important aspect of the application
        that we need to do first.

What should we test first?

    Purchasing tickets
        View the concert listing
            Allowing people to view published concerts
            Not allowing viewing of unpublished concerts
        Pay for the tickets
        View the purchased tickets in the browser
        Send an email confirmation w/ link to the tickets.

We can start by asserting that a user can view a concert listing with a feature test. To do this we create
a new Concert model for a sample concert, make a request to the url and assert that we see the new
concert model's data in the returned view.

When we create factories for models we can take advantage of a laravel feature called factory states which allow us to
modify the factory state without defining it specifically in the create() method.

    We can add this to a factory file...

        /**
        *  Set the Concert factory state to published
        *  @return \Illuminate\Database\Eloquent\Factories\Factory
        */
        public function published() : Factory
        {
            return $this->state(function (array $attributes) {
                return [
                    'published_at' => Carbon::parse('-1 week'),
                ];
            });
        }

    And when we create a factory call it like...

        Concert::factory()->published()->create();


Section 2
---------

Browser testing vs Endpoint testing...

    Browser Testing involves using a tool like Selenium to simulate a user's actions inside the browser.

        Pros...

            Emulates exactly how a user interacts with an application.
            Gives confidence the app is working end to end.

        Cons...

            Introduces a new tool.
            Slower.
            More brittle, UI changes can break it.
            Complex setup.
            Not interacting with code directly, making assertions through the UI.

    Endpoint tests simulate how the browser would interact with the server. Instead of how the user interacts
    with the app.

        Pros...

            Faster.
            Doesn't require additional tooling.
            Interaction with stable data structures, UI changes would break it.
            Interaction directly with code.

        Cons...

            Untested gap between the front and backend.

    It comes down to what do we want from test?

        Confidence that the system works.
        Reliable, don't break for unimportant reasons.
        Fast so they can run often.
        Simple with minimal tooling, easy to recreate a test env.

Now we can start hashing out a purchasing tickets feature in our application. We can start with an endpoint
test.

    We known that we will need a concert to purchase tickets for. The user can make a json request to the
    endpoint with their email, ticket quantity and also a payment token from stripe. We can define a payment
    gateway as the actual stripe gateway and make a request to the stripe servers during the test.

    Another approach would also be to set up a fake payment gateway for the test.

When we are running tests sometimes we can get some more useful errors by overriding the render() method in
App\Exceptions\Handler.php

    /**
     *  Can override this method to rethrow the error. Sometimes has
     *  some more useful info.
     *  @throws Throwable $e
     */
    public function render($request, Throwable $e) : void
    {
        throw $e;
    }

    An even better approach is to call

        $this->withoutExceptionHandling();

    At the start of a test. Sometimes this will give us better errors that provide more useable information.

We have seen in that past that when passing a class into the constructor of a class the laravel
service container can automatically resolve it. This only works if the class has no dependencies or 
only depends on other concrete classes.

    If we have a class that implements an interface and we want to type hint that interface in a class
    constructor we need to tell the container how to resolve that interface.

    In the ConcertOrderController when we pass in an interface in the constructor laravel does not
    known how to resolve this. In our PurchaseTicketsTest we can instruct the service container
    which class we want the interface to resolve to, in this case out FakePaymentGateway for testing.

    $this->app->instance(PaymentGateway::class, $paymentGateway);

When we are doing the same thing to set up all our tests in a file we can use...

    protected function setUp() : void
    {
        parent::setUp();
        $this->paymentGateway = new FakePaymentGateway;
        $this->app->instance(PaymentGateway::class, $this->paymentGateway);
    }

    This will run the setUp() method before every test.


Section 3
---------

We can catch multiple exceptions like so...

    try {
        $this->paymentGateway->charge(
            request('ticket_quantity') * $concert->ticket_price, 
            request('payment_token')
        );

        $order = $concert->orderTickets(
            request('email'), 
            request('ticket_quantity')
        );

        return response()->json([], 201);
    } catch(PaymentFailedException $e) {
        return response()->json([], 422);
    } catch (NotEnoughTicketsException $e) {
        return response()->json([], 422);
    }

Often times when testing we have gotten an instance of a model we might to some operation like an update
and then we want to make an assertion to verify a change. We need to refresh the models state.

    $ticket = $order->tickets()->first();
    $ticket->release();
    $this->assertNull($ticket->fresh()->order_id);

To simplify test we can add methods to the models specifically for testing. Some people don't like this
approach though since these methods have no use except for testing.


Section 5
---------

In the ReservationTest...

There are many instances where we are writing unit tests that do not depend on anything from the database.
Laravel comes with a library called Mockery that allows us to mock out dependencies. So for instance
we can mock out the ticket class specifying a price. Note that this will not actually work in this case
since the 'price' is a computed property, which mockery does not support.

    Mockery::mock(Ticket::class, ['price' => 1200]);

In this case we can actually just pass in a regular collection...

    $tickets = collect([
        (object) ['price' => 1200],
        (object) ['price' => 1200],
        (object) ['price' => 1200]
    ]);

We are type hinting Illuminate\Database\Eloquent\Collection so we need to add a union type for Illuminate\Support\Collection
just for the test.


Section 6
---------

At this point we have cleaned up the controller quite a bit but we have introduced a race condition. A race
condition is when a softwares behavior is dependent on a sequence of events and the resulting behavior
is undesirable.

We have a Reservation class but we aren't doing anything in there to actually reserve them. So this means that
Customer A can be at the charge stage if the checkout process hitting the Stripe API. Customer B can still
come along and want the same tickets as Customer A. Customer A can complete the checkout and then Customer B could
already be on the charge stage which when successful can override Customer A's order tickets.

We want to be able to write a test for this, but how?

    Laravel supports sub-requests. This allows us to have a request within a request so we can mimic this as follows...

        Req A: Find tickets for customer A
            Req B: Find tickets for customer B
            Req B: Attempt charge of customer B
            Req B: Create an order for customer B
        Req A: Attempt charge of customer A
        Req A: Create an order for customer A

    The application should not allow us to continue in the sub request past the step... 
    
        Req B: Find tickets for customer B

    Since we are using the FakePaymentGateway we can create a hook that will allow us to run a callback before
    a user is charged. See the FakePaymentGateway and test for how this is done using callbacks.

In a factory there are often times when we want to create a new instance of a different model, for example
we have a foreign id column and want to create a record for this foreign id.

    In this situation we might want to override this foreign id column when creating a factory when we already
    have a Model.

        public function definition()
        {
            return [
                'concert_id' => Concert::factory()->create()->id;
            ];
        }

    The above will result in a new record being created even if we pass in a concert_id. We can use a callback
    to ONLY create a new record if we do not pass anything into the factory.

        public function definition()
        {
            return [
                'concert_id' => function() {
                    return Concert::factory()->create()->id;
                }
            ];
        }

Let's take the following test...

    public function cannot_purchase_tickets_another_customer_is_already_trying_to_purchase()
    {
        $concert = Concert::factory()
            ->published()
            ->create([
                'ticket_price' => 1200
            ])
            ->addTickets(3);

        $this->paymentGateway->beforeFirstCharge(function($paymentGateway) use($concert) {

            $requestA = $this->app['request'];

            $responseB = $this->orderTickets($concert->id, [
                'email' => 'personB@example.com',
                'ticket_quantity' => 1,
                'payment_token' => $this->paymentGateway->getValidTestToken()
            ]);

            $this->app['request'] = $requestA;

            $responseB->assertStatus(422);
            $this->assertFalse($concert->hasOrderFor('personB@example.com'));
            $this->assertEquals(0, $this->paymentGateway->totalCharges());
        });

        $responseA = $this->orderTickets($concert->id, [
            'email' => 'personA@example.com',
            'ticket_quantity' => 3,
            'payment_token' => $this->paymentGateway->getValidTestToken()
        ]);

        $this->assertEquals(3600, $this->paymentGateway->totalCharges());
        $this->assertTrue($concert->hasOrderFor('personA@example.com'));
        $this->assertEquals(3, $concert->ordersFor('personA@example.com')->first()->ticketQuantity());
    }

In the above test we are trying to simulate two customers making requests at the same time. We are making
a request within a request as outlined above. The test is failing without the 

    $requestA = $this->app['request'];
    $this->app['request'] = $requestA;

        Laravel allows multiple requests but doesn't do anything to manage those requests it only manages 
        one global request. So we have a situation where the request for $responseB is overwriting data
        for the request $responseA

        In the ConcertOrderController we are using the request('email') to create an order for the tickets
        so we are getting the wrong customer email.

        This can be fixed by backing up and then manually setting the request in the service container
        using the two lines above.


Section 7
---------

Laravel comes with a library called mockery that can be used for mocking when writing tests. For instance
we can mock out a class in order to simulate it for testing.

    $ticket1 = Mockery::mock(Ticket::class);
    $ticket1->shouldReceive('release')->once();

    $tickets = collect([$ticket1]);
    $reservation = new Reservation($tickets);

    $reservation->cancel();

We create a new mock of the Ticket class and specifying that the Ticket object that is create will call the
release method once when the reservation is cancelled. If we were to have many tickets above it could get
verbose, we can simplify it a bit using...

    $tickets = collect([
        Mockery::mock(Ticket::class)->shouldReceive('release')->once()->getMock(),
        Mockery::mock(Ticket::class)->shouldReceive('release')->once()->getMock(),
        Mockery::mock(Ticket::class)->shouldReceive('release')->once()->getMock()
    ]);
    $reservation = new Reservation($tickets);

    $reservation->cancel();

Our tests have generally followed the structure of arrange, act, assert. The above tests does not assert anything
The mocks are kind of like assertion but they are part of arrangement as well.

Mockery has a spy method which allows us to set up the mock first and then do the assertions.

    $tickets = collect([
        Mockery::spy(Ticket::class),
        Mockery::spy(Ticket::class),
        Mockery::spy(Ticket::class)
    ]);
    $reservation = new Reservation($tickets);

    $reservation->cancel();

    foreach ($tickets as $ticket) {
        $ticket->shouldHaveReceived('release');
    }


Section 8
---------

Tests are giving us feedback on how our application is designed. Complex test setup could indicate that there
is something wrong with the code.

Code smells are characteristics that possibly indicate that there is a deeper problem. There are three broad
categories of code smells... Application-level, Class-level and Method-level.

Application-level...

    Mysterious Name: functions, modules, variables or classes that are named in a way that does not 
    communicate what they do or how to use them.

    Duplicated code: identical or very similar code that exists in more than one location.

    Contrived complexity: forced usage of overcomplicated design patterns where simpler design 
    patterns would suffice.

    Shotgun surgery: a single change that needs to be applied to multiple classes at the same time.

    Uncontrolled side effects: side effects of coding that commonly cause runtime exceptions, with unit 
    tests unable to capture the exact cause of the problem.

    Variable mutations: mutations that vary widely enough that refactoring the code becomes increasingly 
    difficult, due to the actual value's status as unpredictable and hard to reason about.

    Boolean blindness: easy to assert on the opposite value and still type checks.

Class-level...

    Large class: a class that has grown too large. See God object.

    Feature envy: a class that uses methods of another class excessively.

    Inappropriate intimacy: a class that has dependencies on implementation details of another class.

    Refused bequest: a class that overrides a method of a base class in such a way that the contract 
    of the base class is not honored by the derived class.

    Lazy class/freeloader: a class that does too little.

    Excessive use of literals: these should be coded as named constants, to improve readability and to 
    avoid programming errors. Additionally, literals can and should be externalized into resource 
    files/scripts, or other data stores such as databases where possible, to facilitate localization of 
    software if it is intended to be deployed in different regions.

    Cyclomatic complexity: too many branches or loops; this may indicate a function needs to be broken up
    into smaller functions, or that it has potential for simplification/refactoring.

    Downcasting: a type cast which breaks the abstraction model; the abstraction may have to be 
    refactored or eliminated.

    Orphan variable or constant class: a class that typically has a collection of constants which belong 
    elsewhere where those constants should be owned by one of the other member classes.

    Data clump: Occurs when a group of variables are passed around together in various parts of the program. 
    In general, this suggests that it would be more appropriate to formally group the different variables 
    together into a single object, and pass around only the new object instead.

Method-level...

    Too many parameters: a long list of parameters is hard to read, and makes calling and testing the 
    function complicated. It may indicate that the purpose of the function is ill-conceived and 
    that the code should be refactored so responsibility is assigned in a more clean-cut way.

    Long method: a method, function, or procedure that has grown too large.

    Excessively long identifiers: in particular, the use of naming conventions to provide disambiguation 
    that should be implicit in the software architecture.

    Excessively short identifiers: the name of a variable should reflect its function unless the function is obvious.

    Excessive return of data: a function or method that returns more than what each of its callers needs.

    Excessively long line of code (or God Line): A line of code which is too long, making the code difficult 
    to read, understand, debug, refactor, or even identify possibilities of software reuse.

In lesson 8.3 we can see that Order::forTickets() has too many parameters and these are all part of the Reservation
object. We can refactor to preserve the whole object.

Feature Envy is also apparent here...

    $order = Order::forTickets(
        $reservation->tickets(), 
        $reservation->email(), 
        $reservation->totalCost()
    );

So the problem here can be thought of in both ways but it if we think of it more as a feature envy problem
we can improve the architecture more. Ideally we would like to do something like...

    $order = $reservation->complete();

Sometimes if we get an SQL order when running a test it means we just need to use the RefreshDatabase trait.

The goal is to keep business logic out of the controllers. We can put it in service classes. Service classes are
classes we define that handles some request and encapsulates business logic and persistence away from the action.

    A service class should not do a lot of the work like database access directly but defers to individual classes
    like a User, Order, Inventory class or whatever other classes we may have that implement the lower level
    functionality.

    When we are doing something like a Purchase we need to probably need to take a lot of steps like creating
    an order, charging, calculating shipping, modifying the inventory etc. We don't want to cram all of that
    logic into a single class so we can create a PurchaseService that ties a lot of these smaller actions
    together.

    The service class is really only manipulating other classes.

    The downside of service classes is that they are not very object oriented, they feel procedural.


Section 9
---------

Stripe has a PHP library and API that we are going to start integrating into our application.

Stripe has a create card token which allows us to pass in a credit cards details and return a
created token.

    $stripe = new \Stripe\StripeClient(<STRIPE_SECRET>);

    $token = $stripe->tokens->create([
        'card' => [
            'number' => '4242424242424242',
            'exp_month' => 7,
            'exp_year' => 2023,
            'cvc' => '314',
        ],
    ]);

    If we dump the above we can see that there is a lot of information returned but the thing we are looking
    for is the part...

        "id" => "tok_1LPqyLCrhN5LNYWTolI4WodP"

We want to add the following entries to the env files...

    STRIPE_SECRET=
    STRIPE_KEY=

And then in the services.php file we can add...

    'stripe' => [
        'key' => env('STRIPE_KEY'),
        'secret' => env('STRIPE_SECRET')
    ]

Adn now we can access the keys anywhere within the application using...

    config('services.stripe.secret')

Instead of passing the key in when creating the stripe instance we can pass it in for just the request instead
of passing it in to the global state...

    $stripe = new \Stripe\StripeClient();

    $token = $stripe->tokens->create([
        'card' => [
            'number' => '4242424242424242',
            'exp_month' => 7,
            'exp_year' => 2023,
            'cvc' => '314',
        ],
    ], ['api_key' => config('services.stripe.secret')]);

Stripe has a method for getting a given amount of previous charges, for example getting the last three charges...

    $stripe = new \Stripe\StripeClient(<STRIPE_SECRET>);

    $stripe->charges->all(['limit' => 3]);

When we are running the StripePaymentGatewayTest it has to connect to stripes servers. Notice that the tests run 
slow. The alternative would be to mock out the stripe library when testing.

Mocking the stripe API has some advantages...

    Testing is fast and run without internet access.

There are several cons however...

    Tests will pass even if we are not using Strip correctly

    If stripe makes a change our tests can't be used to confirm our code still works.

    Tests become coupled to a specific implementation

We can get around the issue of our Stripe test requiring the internet and being slow by using groups to skip
integration tests like this. In this context the term integration means any test that is testing the integration
with some external service.

We can define groups in the comments using the following syntax. We can mark methods or classes...

    /**
    *  @group integration
    */

Now when we run the following command these tests will be excluded...

    php artisan test --exclude-group integration

We need to configure laravel to tell the application which payment gateway we want to use since we have both the
Stripe gateway and also a dummy gateway.

We can open the AppServiceProvider.php file and add the following to the register() method...

    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        // We tell laravel which payment gateway to use and how to construct it.
        $this->app->bind(StripePaymentGateway::class, function() {
            return new StripePaymentGateway(config('services.stripe.secret'));
        });

        // Anytime something asks for the PaymentGateway interface provide the StripePaymentGateway
        $this->app->bind(PaymentGateway::class, StripePaymentGateway::class);
    }


Section 10
----------

Right now we have a FakePaymentGateway and a real stripe payment gateway. We could have a situation where
we update how the charge method deals with errors, let's say that it no longer throws an exception and just
returns false. Since we are still using the fake gateway in many tests they will still pass. Our tests are
no longer giving us an accurate picture.

    This is a limitation of interfaces. We need a type of test to test how all payment gateways are supposed
    to work.

    A contract test takes a shared set of tests and applies those tests to many implementations of the
    same interface. We can test that all of the different implementations function correctly from the
    perspective of the rest of the application.

    The idea is that we have a single test to cover multiple implementations of an interface.

On a PHP trait we can define an abstract method. This will ensure that any classes that use the trait must 
have a method with this name.

When we have a test that does not perform any assertions we can suppress the PHPUnit warning by including
the following in the comments...

    @doesNotPerformAssertions


Section 12
----------

There is a useful testing assertion that laravel has called assertViewHas()

    $order = Order::factory()->create([
        'confirmation_number' => 'ORDERCONFIRMATION1234'
    ]);

    $response->assertViewHas('order', $order);

We can use this to test that we are getting the correct order passed to the view. The first argument
is the name of the variable that was passed to the view. The second argument is what we want the variable
passed into the view to be equal to.

This assertion can also accept a closure. Here we are order that was passed into the view to the $order
we create in our test.

    $response->assertViewHas('order', function($viewOrder) use($order) {
        return $order->id === $viewOrder->id;
    });

When testing a view or response we often want to verify that it contains a date. Sometimes we want this date
to be displayed in a very specific. In cases where it is displayed on a page for a user we might want to change
the way it is displayed later on. Then the test will break. To solve this problem we can use a special html
tag...

    <time datetime="{{ $var->date->format('Y-m-d H:i')}}">
        datetime="{{ $var->date->format('User readable format')}}"
    </time>

We can attach a special attribute to the tag and use a consistent generic date format we can test against. The
user will not see this on the screen and only see the readable date within the tags.


Section 13
----------

When running tests with either the phpunit or artisan command we can use the following flag to stop the tests
on the very first failure.

    --stop-on-failure

We can run an individual test using...

    php artisan test --filter test_method_name

We can run tests that only contain the word details...

    php artisan test --filter=details

In Orders.php when we want to use an instance of the OrderConfirmationNumberGenerator interface we can use the
laravel service container to resolve it...

    public static function forTickets(...)
    {
        $order = self::create([
            'confirmation_number' => app(OrderConfirmationNumberGenerator::class)->generate(),
            'email' => $email,
            'amount' => $amount === null ? $tickets->sum('price') : $amount,
        ]);

        ...
    }

However it would be nicer if we could have a simpler way to do this. Laravel has facades built in. Facades
provide a static interface to classes that are available in the application service container. We can
leverage this to convert the above into a nicer static syntax...

    OrderConfirmationNumber::generate();

Normally we could just create a static method but since we are using an interface 'OrderConfirmationNumberGenerator'
so we can have different implementations of the confirmation number generator for testing and production this
won't work.

We can instead create our own facade...

    <?php

    namespace App\Facades;

    use App\OrderConfirmationNumberGenerator;
    use Illuminate\Support\Facades\Facade;

    class OrderConfirmationNumber extends Facade
    {
        protected static function getFacadeAccessor()
        {
            return OrderConfirmationNumberGenerator::class;
        }
    }

Now we can call...

    public static function forTickets(...)
    {
        $order = self::create([
            'confirmation_number' => OrderConfirmationNumber::generate(),
            'email' => $email,
            'amount' => $amount === null ? $tickets->sum('price') : $amount,
        ]);

        ...
    }

And our facade will have access to the generate method of our interface and all the resolution will be handled
by the service container. It just looks a little cleaner now.

Facades have some testing helpers built in. We can call some mockery helper methods that we can use when testing.
For instance on the OrderConfirmationNumber facade...

    OrderConfirmationNumber::shouldReceive('generate')->andReturn('ORDERCONFIRMATION1234');


Section 14
----------

Laravel supports higher order messages for collections. This allows us to use map in a one liner.

    return $this->charges->map->amount()->sum();

In the above line we have a charges collection. We can map over each item in the collection. In this case
each item in the collection is a Charge object, we can then call the amount() method to get the charge amount
and then sum() to get the sum of all the charges in the collection.


Section 15
----------

When we create a custom facade laravel does some things behind the scenes to try to figure out the class behind
the facade when we want to mock that facade in our tests.

    Remember in our custom facades we are providing an interface in getFacadeAccessor() Laravel might not know
    which concrete class this interface should resolve to.

    We can solve this by specifying which class should be mocked in our facade.

    Take the following code...

        class TicketCode extends Facade
        {
            protected static function getFacadeAccessor()
            {
                return TicketCodeGenerator::class;
            }

            protected static function getMockableClass()
            {
                return static::getFacadeAccessor();
            }
        }

    We are simply stating that the class we want to mock is the class that we have specified in the getFacadeAccessor()
    resulting in laravel creating a mock of the TicketCodeGenerator interface in our tests.

We want to be able to generate a short ticket code that concerts can use to verify the ticket is valid. We can't use
the same method for generating confirmation numbers since we want this to be short and and easy to read.

We can use a library called hashids. This library takes a number and gives a unique short string hash of
that number.

    https://hashids.org/php/

When can pass a salt into the constructor when instantiating the library to make our codes unique to our project...

    new Hashids\Hashids('uihuausadhsd');

We can also specify that we want the hashid to be padded as well. This ensures that every hashid will have
a minimum of 6 characters.

    new Hashids\Hashids('uihuausadhsd', 6);

The characters that make up the hash id can be specified as well...

    new Hashids\Hashids('uihuausadhsd', 6, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ');

When mocking out dependencies we can run into a situation where mocks become out of sync with changes we make to
the real classes that they mock.

    Let's imagine we have a facade that accesses an interface and in one of the classes that implements
    that interface we change a method. In the test we are using mockery on the facade and still referring to
    the original method that no longer exists. We can run the test and it will still pass.

    We can set mockery to notify when a test tries to mock a non existent method on an interface. By default
    mockery allows us to mock methods that do not exist on objects or interfaces.

In TestCase.php we can add the following to override the default setup...

    protected function setUp() : void
    {
        parent::setUp();

        Mockery::getConfiguration()->allowMockingNonExistentMethods(false);
    }

We probably wouldn't want to keep this on all the time since there are cases where we might not want this
behavior.


Section 17
----------

In the video an older version of laravel authentication is used. We can use Fortify to handle the applications
authentication.

In config/app.php we need to register Fortify in the service providers...

    'providers' => [
        /*
         * Package Service Providers...
         */
        App\Providers\FortifyServiceProvider::class,
    ],

We can then open the file FortifyServiceProvider and add the following within the boot() method...

    Fortify::loginView(function() {
        return view('auth.login');
    });

Fortify will already define the route for us, we can just tell it to return the login view that we define.

To install laravel dusk the php zip extension must be installed in the docker container. See the
docker file for the latest. Follow the instructions in the documentation for installing dusk and the
web drivers.

    composer require --dev laravel/dusk

    php artisan dusk:install

We will need to update the docker-compose file and add selenium...

  selenium:
    image: selenium/standalone-chrome:latest
    container_name: selenium
    networks:
      - application

We need to create a new env file... 

    .env.dusk.local

    In here we need to ensure that the application URL points to the nginx server...

        APP_URL=http://nginx

    Add a new entry...

        DUSK_DRIVER_URL=http://selenium:4444/wd/hub
    
    Also we need to create a new database solely for dusk use, don't forget to create it in the 
    database too...

        DB_DATABASE=laravel-dusk

We need to modify the driver() method in the DuskTestCase.php file...

    return RemoteWebDriver::create(
        $_ENV['DUSK_DRIVER_URL'] ?? 'http://selenium:4444/wd/hub',
        DesiredCapabilities::chrome()->setCapability(
            ChromeOptions::CAPABILITY, $options
        )
    );

Modify the AppServiceProvider.php file...

    if ($this->app->environment('local', 'testing')) {
        $this->app->register(DuskServiceProvider::class);
    }