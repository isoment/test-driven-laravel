Section 1
---------

What features does the app need?

    Invite promoters
    Creating accounts
    Logging in as a promoter
    Adding concerts
    Editing concerts
    Publishing concerts
    Integration with stripe connect to do direct payouts
    Purchasing tickets

        We don't necessarily want to do these in the order given, we want to go through this list and work through
        what these steps entail and if we even need to do them

            Purchasing tickets, we need this.

            We can do direct payouts with stripe manually. Stripe will accept all the payments from customers, we
            will have all of our payments in an account and every so often we will manually payout to concert
            promoters their cut.

            Publishing concert's doesn't have to be done by the promoter, a promoter can reach out to us and we
            can simply toggle the publishing of a concert for now.

            Editing concerts, the promoter doesn't need access to this right away. They can send an email to us
            with the details and we can enter it manually.

            Adding concerts, same as the above.

            Creating accounts isn't needed since now we have no immediate need after eliminating the above.

            Inviting promoters, same as the above.

        So we come to the conclusion that purchasing the tickets is the most important aspect of the application
        that we need to do first.

What should we test first?

    Purchasing tickets
        View the concert listing
            Allowing people to view published concerts
            Not allowing viewing of unpublished concerts
        Pay for the tickets
        View the purchased tickets in the browser
        Send an email confirmation w/ link to the tickets.

We can start by asserting that a user can view a concert listing with a feature test. To do this we create
a new Concert model for a sample concert, make a request to the url and assert that we see the new
concert model's data in the returned view.

When we create factories for models we can take advantage of a laravel feature called factory states which allow us to
modify the factory state without defining it specifically in the create() method.

    We can add this to a factory file...

        /**
        *  Set the Concert factory state to published
        *  @return \Illuminate\Database\Eloquent\Factories\Factory
        */
        public function published() : Factory
        {
            return $this->state(function (array $attributes) {
                return [
                    'published_at' => Carbon::parse('-1 week'),
                ];
            });
        }

    And when we create a factory call it like...

        Concert::factory()->published()->create();


Section 2
---------

Browser testing vs Endpoint testing...

Browser Testing involves using a tool like Selenium to simulate a user's actions inside the browser.

    Pros...

        Emulates exactly how a user interacts with an application.
        Gives confidence the app is working end to end.

    Cons...

        Introduces a new tool.
        Slower.
        More brittle, UI changes can break it.
        Complex setup.
        Not interacting with code directly, making assertions through the UI.

Endpoint tests simulate how the browser would interact with the server. Instead of how the user interacts with
the app.

    Pros...

        Faster.
        Doesn't require additional tooling.
        Interaction with stable data structures, UI changes would break it.
        Interaction directly with code.

    Cons...

        Untested gap between the front and backend.

It comes down to what do we want from test?

    Confidence that the system works.
    Reliable, don't break for unimportant reasons.
    Fast so they can run often.
    Simple with minimal tooling, easy to recreate a test env.