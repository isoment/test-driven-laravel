Section 1
---------

What features does the app need?

    Invite promoters
    Creating accounts
    Logging in as a promoter
    Adding concerts
    Editing concerts
    Publishing concerts
    Integration with stripe connect to do direct payouts
    Purchasing tickets

        We don't necessarily want to do these in the order given, we want to go through this list and work through
        what these steps entail and if we even need to do them

            Purchasing tickets, we need this.

            We can do direct payouts with stripe manually. Stripe will accept all the payments from customers, we
            will have all of our payments in an account and every so often we will manually payout to concert
            promoters their cut.

            Publishing concert's doesn't have to be done by the promoter, a promoter can reach out to us and we
            can simply toggle the publishing of a concert for now.

            Editing concerts, the promoter doesn't need access to this right away. They can send an email to us
            with the details and we can enter it manually.

            Adding concerts, same as the above.

            Creating accounts isn't needed since now we have no immediate need after eliminating the above.

            Inviting promoters, same as the above.

        So we come to the conclusion that purchasing the tickets is the most important aspect of the application
        that we need to do first.

What should we test first?

    Purchasing tickets
        View the concert listing
            Allowing people to view published concerts
            Not allowing viewing of unpublished concerts
        Pay for the tickets
        View the purchased tickets in the browser
        Send an email confirmation w/ link to the tickets.

We can start by asserting that a user can view a concert listing with a feature test. To do this we create
a new Concert model for a sample concert, make a request to the url and assert that we see the new
concert model's data in the returned view.

When we create factories for models we can take advantage of a laravel feature called factory states which allow us to
modify the factory state without defining it specifically in the create() method.

    We can add this to a factory file...

        /**
        *  Set the Concert factory state to published
        *  @return \Illuminate\Database\Eloquent\Factories\Factory
        */
        public function published() : Factory
        {
            return $this->state(function (array $attributes) {
                return [
                    'published_at' => Carbon::parse('-1 week'),
                ];
            });
        }

    And when we create a factory call it like...

        Concert::factory()->published()->create();


Section 2
---------

Browser testing vs Endpoint testing...

    Browser Testing involves using a tool like Selenium to simulate a user's actions inside the browser.

        Pros...

            Emulates exactly how a user interacts with an application.
            Gives confidence the app is working end to end.

        Cons...

            Introduces a new tool.
            Slower.
            More brittle, UI changes can break it.
            Complex setup.
            Not interacting with code directly, making assertions through the UI.

    Endpoint tests simulate how the browser would interact with the server. Instead of how the user interacts
    with the app.

        Pros...

            Faster.
            Doesn't require additional tooling.
            Interaction with stable data structures, UI changes would break it.
            Interaction directly with code.

        Cons...

            Untested gap between the front and backend.

    It comes down to what do we want from test?

        Confidence that the system works.
        Reliable, don't break for unimportant reasons.
        Fast so they can run often.
        Simple with minimal tooling, easy to recreate a test env.

Now we can start hashing out a purchasing tickets feature in our application. We can start with an endpoint
test.

    We known that we will need a concert to purchase tickets for. The user can make a json request to the
    endpoint with their email, ticket quantity and also a payment token from stripe. We can define a payment
    gateway as the actual stripe gateway and make a request to the stripe servers during the test.

    Another approach would also be to set up a fake payment gateway for the test.

When we are running tests sometimes we can get some more useful errors by overriding the render() method in
App\Exceptions\Handler.php

    /**
     *  Can override this method to rethrow the error. Sometimes has
     *  some more useful info.
     *  @throws Throwable $e
     */
    public function render($request, Throwable $e) : void
    {
        throw $e;
    }

We have seen in that past that when passing a class into the constructor of a class the laravel
service container can automatically resolve it. This only works if the class has no dependencies or 
only depends on other concrete classes.

    If we have a class that implements an interface and we want to type hint that interface in a class
    constructor we need to tell the container how to resolve that interface.

    In the ConcertOrderController when we pass in an interface in the constructor laravel does not
    known how to resolve this. In our PurchaseTicketsTest we can instruct the service container
    which class we want the interface to resolve to, in this case out FakePaymentGateway for testing.

    $this->app->instance(PaymentGateway::class, $paymentGateway);